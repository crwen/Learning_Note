# index

## P1：运行时数据区

**程序计数器**

程序计数器是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。程序计数器是线程私有的，各条线程之间互不影响，独立存储。

如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是本地（Native）方法，计数器值则应为空（Undefined）。

此内存区域是唯一一个在《 Java 虚拟机规范》中没有规定任何内存溢出情况的区域。

**Java 虚拟机栈**

Java 虚拟机栈是线程私有的，每当有新的线程创建时就会给它分配一个栈空间，当线程结束后栈空间就被回收，因此栈与线程拥有相同的生命周期。栈主要用来实现方法的调用与执行，每个方法在执行的时候都会创建一个栈帧用来存储这个方法的局部变量、操作栈、动态链接和方法出口等信息。当一个方法被调用时，会压入一个新的栈帧到这个线程的栈中，当方法调用结束后会弹出这个栈帧，回收掉调用这个方法使用的栈空间。

该区域有两类异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。如果 JVM 栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 OutOfMemoryError 异常（HotSpot 不可以动态扩展，不存在此问题）。

**本地方法栈**

本地方法栈与虚拟机栈的作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法（字节码）服务，而本地方法栈是为虚拟机栈用到的本地（Native）方法服务。调用本地方法时虚拟机栈保持不变，动态链接并直接调用指定的本地方法。

《 Java 虚拟机规范》对本地方法栈中方法所用语言、使用方式与数据结构无强制规定，具体的虚拟机可根据需要自由实现，例如 HotSpot 直接将虚拟机栈和本地方法栈合二为一。

与虚拟机栈一样，本地方法栈也会在栈深度异常和栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError 异常。

**Java 堆**

Java 堆是虚拟机所管理的内存中最大的一块。堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，Java 里几乎所有的对象实例都在这里分配内存。

Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。但对于大对象（例如数组），多数虚拟机实现出于简单、存储高效的考虑会要求连续的内存空间。

Java 堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的 JVM 都是按照可扩展来实现的。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，虚拟机将抛出 OutOfMemoryError 异常。

**方法区**

方法区和 Java 堆一样是各个线程共享的内存区域，它用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

JDK 8 之前使用永久代来实现方法区，这种设计导致了 Java 应用容易遇到内存溢出问题，因为永久代有`-XX:MaxPermSize`的上限，即使不设置也有默认大小。JDK 6 时 HotSpot 的开发团队就准备放弃永久代，改用本地内存来实现方法区，JDK 7 时已经把原本放在永久代的字符串常量池、静态变量等移出，到了 JDK8 时永久代被完全废弃，改用在本地内存中实现的元空间来代替，把 JDK 7 中永久代剩余内容（主要是类型信息）全部移到元空间。

《 Java 虚拟机规范》对方法区的约束很宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾回收。垃圾回收行为在该区域出现较少，主要回收目标是针对常量池的回收和对类型的卸载，一般来说该区域的回收效果比较难令人满意，尤其是类型的卸载，条件十分苛刻。如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError 异常。

**运行时常量池**

运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。一般来说，除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译出来的直接引用也存储在运行时常量池中。

运行时常量池相对于 Class 文件常量池的另一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是说并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被利用的较多的是String 类的 intern\(\) 方法。

由于运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**直接内存**

直接内存不是 JVM 运行时数据区的一部分，也不是《 Java 虚拟机规范》中定义的内存区域，但是这部分内存也被频繁使用，而且也可能导致内存溢出异常。

JDK 1.4 中新加入了 NIO 模型，引入了一种基于通道与缓冲区的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，避免了在 Java 堆和 Native堆中来回复制数据。

本机直接内存的分配不会收到 Java 堆大小的限制，但还是会受到本机总内存大小以及处理器寻址空间的限制，一般配置虚拟机参数时会根据实际内存去设置 `-Xmx` 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError 异常。

## P2：对象创建的过程

当 JVM 遇到一条字节码 new 指令时，首先将检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查这个引用代表的类是否已被加载、解析和初始化，如果没有就必须先执行类加载过程。

在类加载检查通过后虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，分配空间的任务实际上等于把一块确定大小的内存块从 Java 堆中划分出来。假设 Java 堆内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点指示器，分配内存就是把该指针向空闲方向挪动一段与对象大小相等的距离，这种方式叫"指针碰撞"。

如果 Java 堆中的内存不是规整的，那么虚拟机就必须维护一个列表记录哪些内存块是可用的，在分配时从列表中找到一块足够大的空间划分给对象实例并更新列表上的记录，这种方式叫做"空闲列表"。

选择哪种分配方式由堆是否规整决定，堆是否规整又由所用垃圾回收器是否带有空间压缩整理能力决定。因此使用 Serial、ParNew 等带压缩整理的收集器时，系统采用指针碰撞；当使用 CMS 这种基于清除算法的垃圾收集器时，理论上只能采用空间列表分配内存。

**分配内存的线程安全问题：**对象创建在虚拟机中十分频繁，即使修改一个指针所指向的位置在并发情况下也不是线程安全的，可能出现正给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决该问题有两个方法：① 虚拟机采用 CAS 加失败重试的方式保证更新操作的原子性。② 把内存分配的动作按照线程划分在不同空间进行，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB 分配，只有 TLAB 用完了分配新缓冲区时才需要同步。

内存分配完成后虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值，保证对象的实例字段在 Java 代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型对应的零值。之后虚拟机还要对对象进行必要设置，例如对象是哪个类的实例、如何找到类的元数据信息等。

至此从虚拟机的视角来看一个新的对象已经产生了，但从程序的角度来说对象创建才刚开始。此时构造方法，即 Class 文件中的 init 方法还没有执行，所有字段都为默认零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说 new 指令后会接着执行 init 方法，按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。

## **P3：对象的内存布局**

在 HotSpot 虚拟机中，对象在堆内存中的存储布局可分为三个部分。

**对象头**

对象头包括两类信息，第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID等，这部分数据叫做"Mark Word"。

对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，JVM 通过该指针来确定对象是哪个类的实例。并非所有虚拟机实现都必须在对象数据上保留类型指针，查找对象的元数据不一定要经过对象本身。此外如果对象是一个 Java 数组，在对象头还必须有一块用于记录数组长度的数据。

**实例数据**

实例数据部分是对象真正存储的有效信息，即程序员在代码里所定义的各种类型的字段内容。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。

**对齐填充**

这部分不是必然存在的，仅仅起占位符的作用。由于 HotSpot 虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，而对象头已经被设为正好是 8 字节的整数倍，因此如果对象实例数据部分没有对齐，就需要对齐填充来补全。

## P4：对象的访问定位

Java 程序会通过栈上的 reference 数据来操作堆上的具体对象，而具体对象访问方式是由虚拟机决定的，主流的访问方式主要有使用句柄和直接指针两种。

**使用句柄**

如果使用句柄访问，Java 堆中将可能会划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

优点是 reference 中存储的是稳定句柄地址，在对象被移动（处于垃圾收集过程中）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。

**直接指针**

如果使用直接指针访问的话，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话就不需要多一次间接访问的开销。

优点就是速度更快，节省了一次指针定位的时间开销，HotSpot 主要使用的就是直接指针来进行对象访问。

## P5：内存溢出异常

**Java 堆溢出**

Java 堆用于存储对象实例，我们只要不断创建对象，并且保证GC Roots到对象有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆容量的限制后就会产生OOM异常。例如在 while 死循环中一直 new 创建实例。

Java 堆内存的 OOM 是实际应用中最常见的 OOM 情况，常规的处理方法是先通过内存映像分析工具对 Dump 出来的堆转储快照进行分析，确认内存中导致 OOM 的对象是否是必要的，即分清楚到底是出现了内存泄漏还是内存溢出。

如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链，找到泄露对象是通过怎样的引用路径、与哪些GC Roots相关联才导致垃圾收集器无法回收它们，一般可以准确定位到对象创建的位置进而找出产生内存泄漏代码的具体位置。

如果不是内存泄漏，即内存中的对象确实都是必须存活的那就应当检查 JVM 的堆参数设置，与机器的内存相比是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

**虚拟机栈和本地方法栈溢出**

由于HotSpot虚拟机不区分虚拟机和本地方法栈，因此设置本地方法栈大小的参数没有意义，栈容量只能由 `-Xss` 参数来设定，存在两种异常：

* **StackOverflowError：**如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。例如一个递归方法不断调用自己。

  该异常有明确错误堆栈可供分析，容易定位到问题所在。

* **OutOfMemoryError：**如果 JVM 栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。HotSpot 虚拟机不支持虚拟机栈的扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OOM异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。

**运行时常量池溢出**

String类的intern方法是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象的引用，否则会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。

在 JDK6及之前常量池都分配在永久代，因此可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 限制永久代的大小，间接限制常量池的容量。在 while 死循环中不断调用intern方法，之后将导致运行时常量池溢出。

在 JDK7 及之后版本不会导致该问题，因为存放在永久代的字符串常量池已经被移至 Java 堆中。

**方法区溢出**

方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。只要不断在运行时产生大量的类去填满方法区，就会导致溢出。例如使用 JDK 的反射或 CGLib 直接操作字节码在运行时生成大量的类会导致溢出。当前的很多主流框架如Spring、Hibernate等对类增强是都会使用CGLib这类字节码技术，增强的类越多，就需要越大的方法区保证动态生成的新类型可以载入内存，也就更容易导致方法区溢出。

JDK 8 之后永久代完全被废弃，取而代之的是元空间，HotSpot 提供了一些参数作为元空间的防御措施：

`-XX:MaxMetaspaceSize`：设置元空间的最大值，默认 -1，表示不限制即只受限于本地内存大小。

`-XX:MetaspaceSize`：指定元空间的初始大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量空间就适当降低该值，如果释放了很少的空间就适当提高该值。

`-XX:MinMetaspaceFreeRatio`：作用是在垃圾收集之后控制最小的元空间剩余容量百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有`-XX:MinMetaspaceFreeRatio`，用于控制最大的元空间剩余容量百分比。

**本机直接内存溢出**

直接内存的容量大小可通过 `-XX:MaxDirectMemorySize` 指定，如果不去指定则默认与 Java 堆的最大值一致。

由直接内存导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见有什么明显的异常情况，如果发现内存溢出后产生的Dump 文件很小，而程序中又直接或间接使用了直接内存（典型的间接使用就是 NIO），那么就可以考虑检查直接内存方面的原因。

## P6：判断对象是否是垃圾

在堆中存放着所有对象实例，垃圾收集器在对堆进行回收前，首先要判断对象是否还存活着。

**引用计数算法**

在对象中添加一个引用计数器，如果有一个地方引用它计数器就加1，引用失效时计数器就减1，如果计数器为0则该对象就是不再被使用的。该算法原理简单，效率也高，但是在 Java中很少使用，因为它存在对象之间互相循环引用的问题，导致计数器无法清零。

**可达性分析算法**

当前主流语言的内存管理子系统都是使用可达性分析算法来判断对象是否存活的。这个算法的基本思路就是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到GC Roots之间没有任何引用链相连，则此对象是不可能再被使用的。

可作为GC Roots的对象：

* 在虚拟机栈中引用的对象，如线程被调用的方法堆栈中的参数、局部变量等。
* 在方法区中类静态属性引用的对象，如类的引用类型静态变量。
* 在方法区中常量引用的对象，如字符串常量池中的引用。
* 在本地方法栈中 JNI 即 Native 方法引用的对象。
* JVM 内部的引用，如基本数据类型对应的 Class 对象，一些常驻异常对象，系统类加载器等。
* 所有被 synchronized 同步锁持有的对象。

## P7：引用类型

无论通过引用计数还是可达性分析判断对象是否存活，都和引用离不开关系。在 JDK1.2 之前引用的定义是：如果 reference 类型数据存储的数值代表另外一块内存的起始地址，那么就称该 reference 数据是代表某块内存、某个对象的引用。在 JDK 1.2之后 Java 对引用的概念进行了扩充，按强度分为四种：

**强引用**：最传统的引用定义，指代码中普遍存在的引用赋值。任何情况下只要强引用存在，垃圾收集器就永远不会回收被引用的对象。

**软引用**：描述一些还有用但非必需的对象。只被软引用关联的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围中进行二次回收，如果这次回收还没有足够的内存才会抛出 OOM 异常。

**弱引用**：描述非必需对象，引用强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器开始工作时无论当前内存是否足够都会回收只被弱引用关联的对象。

**虚引用**：也称幽灵引用或幻影引用，是最弱的引用关系。一个对象是否有虚引用存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象实例。该引用的唯一目的就是为了能在这个对象被垃圾收集器回收时收到一个系统通知。

## P8：GC 算法

**标记-清除算法**

* **原理：**分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象，或者标记存活的对象并统一回收所有未被标记的对象。标记过程就是判断对象是否属于垃圾的过程。
* **特点：**① 执行效率不稳定，如果堆中包含大量对象且其中大部分是需要被回收的，这时必须进行大量标记和清除，导致效率随对象数量增长而降低。② 内存空间碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时无法找出足够的连续内存而不得不提前触发另一次垃圾收集。

**标记-复制算法**

* **原理：**将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的空间用完了，就将还存活着的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。
* **特点：**① 实现简单、运行高效，解决了内存碎片问题。② 代价是将可用内存缩小为原来的一半，浪费了过多空间。
* **HotSpot 的新生代划分：**

  把新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时将 Eden 和 Survivor 中仍然存活的对象一次性复制到另一块 Survivor 上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，即每次新生代中可用空间为整个新生代的90%。

**标记-整理算法**

* **原理：**标记-复制算法在对象存活率较高时要进行较多的复制操作，效率将会降低。并且如果不想浪费空间，就需要有额外空间进行分配担保，应对被使用内存中所有对象都100%存活的极端情况，所以老年代一般不使用此算法。老年代使用标记-整理算法，标记过程与标记-清除算法一样，只是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
* **特点：**标记-清除与标记-整理的本质差异在于前者是一种非移动式回收算法而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险策略：① 如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，是一种极为负重的操作，而且这种移动必须全程暂停用户线程才能进行。② 如果不移动对象就会导致空间碎片问题，只能依赖更复杂的内存分配器和内存访问器来解决。所以是否移动对象都存在弊端，移动则内存回收时更复杂，不移动则内存分配时更复杂。

## P9：垃圾收集器

**经典垃圾收集器：**指 JDK 11之前的全部可用垃圾收集器。

**Serial**

最基础、历史最悠久的收集器，该收集器是一个使用复制算法的单线程工作收集器，单线程的意义不仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调它进行垃圾收集时必须暂停其他所有工作线程直到收集结束。

Serial 是虚拟机运行在客户端模式下的默认新生代收集器，优点是简单高效，对于内存受限的环境它是所有收集器中最小的；对于单核处理器或处理器核心较少的环境来说，Serial 收集器由于没有线程交互开销，因此可获得最高的单线程收集效率。

**ParNew**

实质上是 Serial 的多线程版本，除了使用多线程进行垃圾收集外其余行为完全一致。

ParNew 是虚拟机运行在服务端模式下的默认新生代收集器，一个重要原因是除了 Serial 外只有它能与 CMS 配合。自从 JDK 9 开始，ParNew 加 CMS 收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了，官方希望他能被 G1 完全取代。

**Parallel Scavenge**

新生代收集器，基于标记-复制算法，是可以并行的多线程收集器，与 ParNew 类似。

特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能缩短收集时用户线程的停顿时间，而 Parallel Scavenge 的目标是达到一个可控制的吞吐量，吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值。自适应调节策略也是它区别于 ParNew 的一个重要特性。

**Serial Old**

Serial 的老年代版本，同样是一个单线程收集器，使用标记-整理算法。

Serial Old 是虚拟机在客户端模式下的默认老年代收集器，用于服务端有两种用途：一种是 JDK 5 及之前与 Parallel Scavenge 搭配使用，另一种是作为CMS 发生失败时的预案。

**Parellel Old**

Parallel Scavenge 的老年代版本，支持多线程收集，基于标记-整理算法实现。这个收集器直到 JDK 6 才开始提供，在注重吞吐量优先的场景可以有效考虑Parallel Scavenge 加 Parallel Old 组合。

**CMS**

以获取最短回收停顿时间为目标的收集器，如果希望系统停顿时间尽可能短以给用户带来更好的体验就可以使用 CMS。

基于标记-清除算法，过程相对复杂，分为四个步骤：初始标记、并发标记、重新标记、并发清除。

其中初始标记和重新标记仍然需要 STW（Stop The World，表示系统停顿），初始标记仅是标记 GC Roots 能直接关联到的对象，速度很快。并发标记就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程并发运行。重新标记则是为了修正并发标记期间因用户程序运作而导致标记产生变动的那一部分对象的标记记录，该阶段停顿时间比初始标记稍长，但远比并发标记短。最后是并发清除，清理标记阶段判断的已死亡对象，由于不需要移动存活对象，因此该阶段也可以与用户线程并发。

由于整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器都可以和用户线程一起工作，所以从总体上说CMS 的内存回收过程是与用户线程并发执行的。

CMS 是 HotSpot 追求低停顿的第一次成功尝试，但还存在三个明显缺点：① 对处理器资源非常敏感，在并发阶段虽然不会导致用户线程暂停，但会降低总吞吐量。② 无法处理浮动垃圾，有可能出现并发失败而导致另一次 FullGC。③ 由于基于标记-清除算法，因此会产生大量空间碎片，给大对象分配带来麻烦。

**G1**

开创了收集器面向局部收集的设计思路和基于Region的内存布局，是一款主要面向服务端的收集器，最初设计目标是替换CMS。

G1 之前的收集器，垃圾收集的目标要么是整个新生代，要么是整个老年代或整个堆。而 G1 可以面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收受益最大，这就是 G1 的 MixedGC 模式。

不再坚持固定大小及数量的分代区域划分，而是把 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要扮演新生代的 Eden 空间、Survivor 空间或老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

跟踪各个 Region 里面的垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的经验值，在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值收益最大的 Region。这种回收方式保证了 G1 在有限的时间内获取尽可能高的收集效率。

G1的运作过程：

* **初始标记：**标记 GC Roots 能直接关联到的对象并修改 TAMS 指针的值，让下一阶段用户线程并发运行时能正确地在可用 Region 中分配新对象。该阶段需要 STW 但耗时很短，是借用进行 MinorGC 时同步完成的。
* **并发标记：**从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图，找出需要回收的对象。该阶段耗时长，但可与用户线程并发执行，当对扫描完成后还要重新处理 SATB 记录的在并发时有引用变动的对象。
* **最终标记：**对用户线程做一个短暂暂停，用于处理并发阶段结束后仍遗留下来的少量 SATB 记录。
* **筛选回收：**对各个 Region 的回收价值和成本排序，根据用户期望的停顿时间指定回收计划，可自由选择任意多个 Region 构成回收集然后把决定回收的那一部分的存活对象复制到空的 Region 中，再清理掉整个旧的 Region 的全部空间。该操作必须暂停用户线程，由多条收集器线程并行完成。

可以由用户指定期望的停顿时间是 G1 的一个强大功能，但该值不能设得太低，一般设置为100~300毫秒比较合适。G1不会存在内存空间碎片的问题，但 G1 为了垃圾收集产生的内存占用和程序运行时的额外执行负载都高于CMS。

**低延迟垃圾收集器：**指 Shenandoah 和 ZGC，这两个收集器几乎整个工作过程全都是并发的，只有初始标记、最终标记这些阶段有短暂停顿，停顿的时间基本上是固定的。

**Shenandoah**

相比 G1 内存布局同样基于 Region，默认回收策略也是优先处理回收价值最大的 Region。但在管理堆内存方面，与 G1 有不同：① 支持并发整理，G1 的回收阶段不能与用户线程并发。②默认不使用分代收集，不会有专门的新生代 Region 或老年代 Region。③ 摒弃了在 G1 中耗费大量内存和计算资源去维护的记忆集，改用名为连接矩阵的全局数据结构来记录跨 Region 的引用关系。

**ZGC**

JDK11中新加入的具有实验性质的低延迟垃圾收集器，和 Shenandoah 的目标高度相似，都希望在尽可能对吞吐量影响不大的前提下实现在任意堆大小下都可以把垃圾收集器的停顿时间限制在 10ms 以内的低延迟。

基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理，以低延迟为首要目标。内存布局也采用基于 Region 的堆内存布局，但不同的是 ZGC 的 Region 具有动态性，是动态创建和销毁的，并且区容量大小也是动态变化的。

## P10：内存分配与回收策略

以 Seial + Serial Old 客户端默认收集器组合为例：

**对象优先在 Eden 区分配**

大多数情况下对象在新生代 Eden 区分配，当 Eden 区没有足够空间进行分配时虚拟机将发起一次 MinorGC。

可通过 `-XX:Xms` 和 `-XX:Xmx` 设置堆大小， `-Xmn` 设置新生代的大小， `-XX:SurvivorRatio` 设置新生代中 Eden 和 Survivor的比例。

**大对象直接进入老年代**

大对象是指需要大量连续内存空间的对象，最典型的是很长的字符串或者元素数量很庞大的数组。大对象容易导致内存明明还有不少空间时就提前触发垃圾收集以获得足够的连续空间才能安置它们，当复制对象时大对象就意味着高额内存复制开销。

HotSpot 提供了 `-XX:PretenureSizeThreshold` 参数，大于该值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间来回复制产生大量内存复制操作。

**长期存活对象进入老年代**

虚拟机给每一个对象定义了一个对象年龄计数器，存储在对象头。对象通常在 Eden 诞生，如果经历过第一次 MinorGC 仍然存活并且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1。对象在 Survivor 中每熬过一次 MinorGC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。对象晋升老年代的年龄阈值可通过 `-XX:MaxTenuringThreshold` 设置。

**动态对象年龄判定**

为了适应不同程序的内存状况，虚拟机并不永远要求对象年龄达到阈值才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代，无需等到 `-XX:MaxTenuringThreshold` 参数设置的年龄。

**空间分配担保**

发生 MinorGC 前，虚拟机必须先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 MinorGC可以确定是安全的。

如果不成立，虚拟机会先查看 `-XX:HandlePromotionFailure` 参数的值是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将冒险尝试一次 MinorGC，如果不满足或不允许担保失败就会改成一次 FullGC。

之所以说冒险是因为新生代使用复制算法，为了内存利用率只使用其中一个 Survivor 作为备份，因此当出现大量对象在 MinorGC 后仍然存活的情况时需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。

## P11：故障处理工具

**jps：虚拟机进程状况工具**

jps 即 JVM Process Status，参考了 UNIX 命令的命名格式，功能和 ps 命令类似：可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（LVMID\)。LVMID 与操作系统的进程 ID（PID）是一致的，使用 Windows 的任务管理器或 UNIX 的 ps 命令也可以查询到虚拟机进程的 LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位就必须依赖 jps 命令。

jps 还可以通过 RMI 协议查询开启了 RMI 服务的远程虚拟机进程状态，参数 hostid 为 RMI 注册表中注册的主机名。

**jstat：虚拟机统计信息监视工具**

jstat 即 JVM Statistic Monitoring Tool，是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译器等运行时数据，在没有 GUI 界面的服务器上是运行期定位虚拟机性能问题的常用工具。

一些参数的含义：S0 和 S1 表示两个 Survivor 区，E 表示新生代，O 表示老年代，YGC 表示 Young GC 次数，YGCT 表示Young GC 耗时，FGC 表示 Full GC 次数，FGCT 表示 Full GC 耗时，GCT 表示所有 GC 总耗时。

**jinfo：Java 配置信息工具**

jinfo 表示 Configuration Info for Java，作用是实时查看和调整虚拟机各项参数，使用 jps 的 -v 参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值就只能使用 jinfo 的 -flag 选项进行查询。jinfo 还可以把虚拟机进程的 System.getProperties\(\) 的内容打印出来。

**jmap：Java 内存映像工具**

jmap 表示 Memory Map for Java，jamp 命令用于生成堆转储快照，还可以查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率，当前使用的是哪种收集器等。和 jinfo 命令一样，有部分功能在 Windows 平台下受限，除了生成堆转储快照的 -dump 选项和用于查看每个类实例的 -histo 选项外，其余选项都只能在 Linux 使用。

**jhat：虚拟机堆转储快照分析工具**

jhat 表示 JVM Heap Analysis Tool，JDK 提供 jhat 命令与 jmap 搭配使用来分析 jamp 生成的堆转储快照。jhat 内置了一个微型的 HTTP/Web 服务器，生成堆转储快照的分析结果后可以在浏览器中查看。

**jstack：Java 堆栈跟踪工具**

jstack 表示 Stack Trace for Java，jstack 命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。线程出现停顿时通过 jstack 查看各个线程的调用堆栈，就可以获知没有响应的现场到底在后台做什么或等待什么资源。

除了上述的基础故障处理工具，还有一些可视化故障处理工具，例如 JHSDB 基于服务性代理的调试工具、JConsole Java 监视与管理控制台、VisualVM 多合一故障处理工具、Java Mission Control 可持续在线监控工具。

## P12：类加载机制和初始化时机

在 Class 文件中描述的各类信息最终都需要加载到虚拟机后才能运行和使用。JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java类型，这个过程被称为虚拟机的类加载机制。与其他在编译时需要连接的语言不同，Java 中类型的加载、连接和初始化都是在程序运行期间完成的，这种策略让 Java 进行类加载时增加了性能开销，但却为 Java 应用提供了极高的扩展性和灵活性，Java 可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分统称为连接。加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的动态绑定特性。

关于何时需要开始类加载的第一个阶段"加载"，《 Java 虚拟机规范》没有强制约束，但对于初始化严格规定了有且只有6种情况：

* 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有初始化则需要先触发初始化。典型场景有：① 使用new关键字实例化对象。② 读取或设置一个类型的静态字段。③ 调用一个类型的静态方法。
* 对类型进行反射调用时，如果类型没有初始化则需要先触发初始化。
* 当初始化类时，如果其父类没有初始化则需要先触发父类的初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类即包含 main 方法的类，虚拟机会先初始化该类。
* 当使用 JDK 7 新加入的动态语言支持时，如果 MethodHandle 实例的解析结果为指定类型的方法句柄且这个句柄对应的类没有进行过初始化，则需要先触发其初始化。
* 当一个接口定义了默认方法时，如果该接口的实现类发生初始化，那接口要在其之前初始化。

除了这六种情况外其余所有引用类型的方式都不会触发初始化，称为被动引用。被动引用的实例：① 子类使用父类的静态字段时，只有直接定义这个字段的父类会被初始化。② 通过数组定义使用类。③ 常量在编译期会存入调用类的常量池，不会初始化定义常量的类。

接口的加载过程和类真正有所区别的是当初始化类时，如果其父类没有初始化则需要先触发其父类的初始化，但在一个接口初始化时并不要求其父接口全部完成了初始化，只有在真正使用到父接口时（如引用接口中定义的常量）才会初始化。

## P13：类加载过程

**加载**

加载是类加载的第一个阶段，在该阶段虚拟机需要完成三件事：① 通过一个类的全限定类名来获取定义此类的二进制字节流。② 将这个字节流所代表的静态存储结构转化为方法区的运行时数据区结构。③ 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。

加载结束后，虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中了，方法区中的数据存储格式完全由虚拟机自定义实现。类型数据安置在方法区之后，会在 Java 堆中实例化一个 Class 对象，这个对象将作为程序员访问方法区中类型数据的外部接口。加载与连接的部分动作是交叉进行的，加载尚未完成时连接可能已经开始。

**验证**

验证是连接的第一步，目的是确保 Class 文件的字节流中包含的信息符合约束要求，保证这些信息不会危害虚拟机的安全。Java 语言本身是安全的，但如果虚拟机不检查输入的字节流，对其完全信任的话，很可能因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃。

验证主要包含了四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。

验证对于虚拟机的类加载机制来说是一个非常重要但非必需的阶段，因为验证只有通过与否的区别，只要通过了验证其后就对程序运行期没有任何影响了。如果程序运行的全部代码都已被反复使用和验证过，在生产环境的就可以考虑关闭大部分类验证措施缩短类加载时间。

**准备**

准备是正式为类变量分配内存并设置零值的阶段，该阶段进行的内存分配仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。如果变量被final修饰，编译时 Javac 会为变量生成 ConstantValue 属性，那么在准备阶段虚拟机就会将该变量的值设为程序员指定的值。

**解析**

解析是将常量池内的符号引用替换为直接引用的过程。

* **符号引用：**符号引用以一组符号描述引用目标，可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。与虚拟机内存布局无关，引用目标并不一定是已经加载到虚拟机内存中的内容。
* **直接引用：**直接引用是可以直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。和虚拟机的内存布局直接相关，引用目标必须已在虚拟机的内存中存在。

解析部分主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符合引用进行。

**初始化**

初始化是类加载过程的最后一步，直到该阶段，JVM 才真正开始执行类中编写的代码。

准备阶段时变量已经赋过一次系统零值，而在初始化阶段会根据程序员的编码去初始化类变量和其他资源。

初始化阶段就是执行类构造器 \ 方法的过程，该方法是 Javac 编译器自动生成的。

## P14：类加载器和双亲委派模型

类加载阶段中"通过一个类的全限定名来获取描述该类的二进制字节流"的动作被设计为放到 JVM 外部实现，以便让应用程序自己决定如何获取所需的类，实现这个动作的代码就是类加载器。

**比较两个类是否相等：**对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。只有在两个类是由同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个 Class 文件，被同一个 JVM 加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

从 JVM 的角度看只存在两种不同的类加载器：一种是启动类加载器，由 C++ 语言实现，是虚拟机自身的一部分；另一种是其他所有类加载器，由 Java 语言实现，独立存在于虚拟机外部且全部继承自抽象类 `java.lang.ClassLoader`。

自 JDK1.2 起 Java 一直保持着三层类加载器、双亲委派的类加载结构。

* **启动类加载器**：负载加载存放在 `JAVA_HOME/lib` 目录，或者指定路径中存放的能够被虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，如果用户需要把加载请求委派给启动类加载器，直接使用 null 代替即可。
* **扩展类加载器**：负载加载 `JAVA_HOME/lib/ext` 目录，或者系统变量所指定的路径中的类库。这种扩展机制在 JDK 9 后被模块化所取代，由于扩展类加载器是由 Java 编写的，开发者可以直接在程序中使用扩展类加载器来加载 Class 文件。
* **应用程序类加载器**：也称系统类加载器，负载加载用户类路径上的所有类库，同样可以直接在代码中使用。如果应用程序中没有自定义类加载器，一般情况下该类加载器就是程序中默认的类加载器。

**双亲委派模型**

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承关系来实现的，而通常使用组合关系来复用父加载器的代码。

如果一个类加载器收到了类加载请求，它不会自己去尝试加载这个类，而首先将该请求委派给自己的父加载器完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成请求时，子加载器才会尝试自己完成加载。

好处是 Java 中的类跟随它的类加载器一起具备了一种带有优先级的层次关系，可以保证某个类在程序的各个类加载器环境中都是同一个类，对于保证程序的稳定运行极为重要。

## P15：Java 程序运行的过程

**通过 Javac 编译器将 .java 代码转为 JVM 可以加载的 .class 字节码文件。**

Javac 编译器是由 Java 语言编写的程序，从 Javac 代码的总体结构看，编译过程可以分为 1 个准备过程和 3 个处理过程：① 准备过程：初始化插入式注解处理器。② 解析与填充符号表过程：进行词法、语法分析，将源代码的字符流转为标记集合，构造出抽象语法树。填充符号表，产生符号地址和符号信息。③ 插入式注解处理器的注解处理过程。④ 分析与字节码生成过程，包括标注检查，对语法的静态信息进行检查；数据流及控制流分析，对程序动态运行过程进行检查；解语法糖，将简化代码编写的语法糖还原为原有的形式；字节码生成，将前面各个步骤的信息转换为字节码。

Javac 属于前端编译器，完成了从程序到抽象语法树或中间字节码的生成，在此之后还有一组内置于 JVM 内部的后端编译器，即即时编译器或提前编译器，来完成代码优化以及从字节码生成本地机器码的过程。

**通过即时编译器 JIT 把字节码文件编译成本地机器码。**

Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为"热点代码"，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，在运行时虚拟机会把这些代码编译成本地机器码，并尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。

客户端编译器的执行过程：① 平台独立的前端将字节码构造成一种高级中间代码表示 HIR。② 平台相关的后端从 HIR 中产生低级中间代码表示 LIR。③ 在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。

服务端编译器专门面向服务端的典型应用场景，并为服务器的性能配置针对性调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器，它会执行大部分经典的优化动作，如无用代码消除、循环表达式外提、消除公共子表达式、基本块重排序等，还会实施一些与 Java 语言特性相关的优化，如范围检查消除、空值检查消除等，也可能根据解释器或客户端编译器提供的性能监控信息进行一些不稳定的预测性激进优化。

**还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。**

